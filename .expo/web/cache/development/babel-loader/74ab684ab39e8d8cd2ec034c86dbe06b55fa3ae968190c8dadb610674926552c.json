{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport { toByteArray } from 'base64-js';\nimport { UnavailabilityError } from 'expo-modules-core';\nimport { CryptoDigestAlgorithm, CryptoEncoding } from \"./Crypto.types\";\nimport ExpoCrypto from \"./ExpoCrypto\";\nexport * from \"./Crypto.types\";\nvar CryptoError = function (_TypeError) {\n  _inherits(CryptoError, _TypeError);\n  function CryptoError(message) {\n    var _this;\n    _classCallCheck(this, CryptoError);\n    _this = _callSuper(this, CryptoError, [`expo-crypto: ${message}`]);\n    _this.code = 'ERR_CRYPTO';\n    return _this;\n  }\n  return _createClass(CryptoError);\n}(_wrapNativeSuper(TypeError));\nexport function getRandomBytes(byteCount) {\n  assertByteCount(byteCount, 'getRandomBytes');\n  var validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      var array = new Uint8Array(validByteCount);\n      for (var i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoCrypto.getRandomValues) {\n    var byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64String) {\n    var base64 = ExpoCrypto.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytes');\n  }\n}\nexport function getRandomBytesAsync(_x) {\n  return _getRandomBytesAsync.apply(this, arguments);\n}\nfunction _getRandomBytesAsync() {\n  _getRandomBytesAsync = _asyncToGenerator(function* (byteCount) {\n    assertByteCount(byteCount, 'getRandomBytesAsync');\n    var validByteCount = Math.floor(byteCount);\n    if (ExpoCrypto.getRandomValues) {\n      var byteArray = new Uint8Array(validByteCount);\n      ExpoCrypto.getRandomValues(byteArray);\n      return byteArray;\n    } else if (ExpoCrypto.getRandomBase64StringAsync) {\n      var base64 = yield ExpoCrypto.getRandomBase64StringAsync(validByteCount);\n      return toByteArray(base64);\n    } else {\n      throw new UnavailabilityError('expo-crypto', 'getRandomBytesAsync');\n    }\n  });\n  return _getRandomBytesAsync.apply(this, arguments);\n}\nfunction assertByteCount(value, methodName) {\n  if (typeof value !== 'number' || isNaN(value) || Math.floor(value) < 0 || Math.floor(value) > 1024) {\n    throw new TypeError(`expo-crypto: ${methodName}(${value}) expected a valid number from range 0...1024`);\n  }\n}\nfunction assertAlgorithm(algorithm) {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(`Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.')}`);\n  }\n}\nfunction assertData(data) {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\nfunction assertEncoding(encoding) {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(`Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(CryptoEncoding).join(', CryptoEncoding.')}`);\n  }\n}\nexport function digestStringAsync(_x2, _x3) {\n  return _digestStringAsync.apply(this, arguments);\n}\nfunction _digestStringAsync() {\n  _digestStringAsync = _asyncToGenerator(function* (algorithm, data) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      encoding: CryptoEncoding.HEX\n    };\n    if (!ExpoCrypto.digestStringAsync) {\n      throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n    }\n    assertAlgorithm(algorithm);\n    assertData(data);\n    assertEncoding(options.encoding);\n    return yield ExpoCrypto.digestStringAsync(algorithm, data, options);\n  });\n  return _digestStringAsync.apply(this, arguments);\n}\nexport function getRandomValues(typedArray) {\n  ExpoCrypto.getRandomValues(typedArray);\n  return typedArray;\n}\nexport function randomUUID() {\n  return ExpoCrypto.randomUUID();\n}\nvar digestLengths = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, CryptoDigestAlgorithm.SHA1, 20), CryptoDigestAlgorithm.SHA256, 32), CryptoDigestAlgorithm.SHA384, 48), CryptoDigestAlgorithm.SHA512, 64), CryptoDigestAlgorithm.MD2, 16), CryptoDigestAlgorithm.MD4, 16), CryptoDigestAlgorithm.MD5, 16);\nexport function digest(algorithm, data) {\n  return new Promise(function (resolve, reject) {\n    try {\n      if (typeof ExpoCrypto.digestAsync === 'function') {\n        resolve(ExpoCrypto.digestAsync(algorithm, data));\n      } else {\n        var output = new Uint8Array(digestLengths[algorithm]);\n        ExpoCrypto.digest(algorithm, output, data);\n        resolve(output.buffer);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}","map":{"version":3,"names":["toByteArray","UnavailabilityError","CryptoDigestAlgorithm","CryptoEncoding","ExpoCrypto","CryptoError","_TypeError","_inherits","message","_this","_classCallCheck","_callSuper","code","_createClass","_wrapNativeSuper","TypeError","getRandomBytes","byteCount","assertByteCount","validByteCount","Math","floor","__DEV__","global","nativeCallSyncHook","__REMOTEDEV__","array","Uint8Array","i","random","getRandomValues","byteArray","getRandomBase64String","base64","getRandomBytesAsync","_x","_getRandomBytesAsync","apply","arguments","_asyncToGenerator","getRandomBase64StringAsync","value","methodName","isNaN","assertAlgorithm","algorithm","Object","values","includes","keys","join","assertData","data","assertEncoding","encoding","digestStringAsync","_x2","_x3","_digestStringAsync","options","length","undefined","HEX","typedArray","randomUUID","digestLengths","_defineProperty","SHA1","SHA256","SHA384","SHA512","MD2","MD4","MD5","digest","Promise","resolve","reject","digestAsync","output","buffer","error"],"sources":["/Users/wmaeda/Documents/me/React Native/react-native-boilerplate/node_modules/expo-crypto/src/Crypto.ts"],"sourcesContent":["import { toByteArray } from 'base64-js';\nimport { UnavailabilityError, UintBasedTypedArray, IntBasedTypedArray } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\ndeclare const global: any;\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * Falls back to `Math.random` during development to prevent issues with React Native Debugger.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return An array of random bytes with the same length as the `byteCount`.\n */\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      // remote javascript debugging is enabled\n      const array = new Uint8Array(validByteCount);\n      for (let i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64String) {\n    const base64 = ExpoCrypto.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytes');\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return A promise that fulfills with an array of random bytes with the same length as the `byteCount`.\n */\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64StringAsync) {\n    const base64 = await ExpoCrypto.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytesAsync');\n  }\n}\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-crypto: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * The `digestStringAsync()` method of `Crypto` generates a digest of the supplied `data` string with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * You can specify the returned string format as one of `CryptoEncoding`. By default, the resolved value will be formatted as a `HEX` string.\n * On web, this method can only be called from a secure origin (HTTPS) otherwise, an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @param options Format of the digest string. Defaults to: `CryptoDigestOptions.HEX`.\n * @return Return a Promise which fulfills with a value representing the hashed input.\n *\n * @example\n * ```ts\n * const digest = await Crypto.digestStringAsync(\n *   Crypto.CryptoDigestAlgorithm.SHA512,\n *   'ðŸ¥“ Easy to Digest! ðŸ’™'\n * );\n * ```\n */\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n\n/**\n * The `getRandomValues()` method of `Crypto` fills a provided `TypedArray` with cryptographically secure random values.\n *\n * @param typedArray An integer based [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) to fill with cryptographically secure random values. It modifies the input array in place.\n * @return The input array filled with cryptographically secure random values.\n *\n * @example\n * ```ts\n * const byteArray = new Uint8Array(16);\n * Crypto.getRandomValues(byteArray);\n * console.log('Your lucky bytes: ' + byteArray);\n * ```\n */\nexport function getRandomValues<T extends IntBasedTypedArray | UintBasedTypedArray>(\n  typedArray: T\n): T {\n  ExpoCrypto.getRandomValues(typedArray);\n  return typedArray;\n}\n\n/**\n * The `randomUUID()` method returns a unique identifier based on the V4 UUID spec (RFC4122).\n * It uses cryptographically secure random values to generate the UUID.\n *\n * @return A string containing a newly generated UUIDv4 identifier\n * @example\n * ```ts\n * const UUID = Crypto.randomUUID();\n * console.log('Your UUID: ' + UUID);\n * ```\n */\nexport function randomUUID(): string {\n  return ExpoCrypto.randomUUID();\n}\n\nconst digestLengths = {\n  [CryptoDigestAlgorithm.SHA1]: 20,\n  [CryptoDigestAlgorithm.SHA256]: 32,\n  [CryptoDigestAlgorithm.SHA384]: 48,\n  [CryptoDigestAlgorithm.SHA512]: 64,\n  [CryptoDigestAlgorithm.MD2]: 16,\n  [CryptoDigestAlgorithm.MD4]: 16,\n  [CryptoDigestAlgorithm.MD5]: 16,\n};\n\n/**\n * The `digest()` method of `Crypto` generates a digest of the supplied `TypedArray` of bytes `data` with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * On web, this method can only be called from a secure origin (HTTPS) otherwise, an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @return A Promise which fulfills with an ArrayBuffer representing the hashed input.\n * @example\n * ```ts\n * const array = new Uint8Array([1, 2, 3, 4, 5]);\n * const digest = await Crypto.digest(Crypto.CryptoDigestAlgorithm.SHA512, array);\n * console.log('Your digest: ' + digest);\n * ```\n */\nexport function digest(algorithm: CryptoDigestAlgorithm, data: BufferSource): Promise<ArrayBuffer> {\n  return new Promise((resolve, reject) => {\n    try {\n      if (typeof ExpoCrypto.digestAsync === 'function') {\n        resolve(ExpoCrypto.digestAsync(algorithm, data));\n      } else {\n        const output = new Uint8Array(digestLengths[algorithm]);\n        ExpoCrypto.digest(algorithm, output, data);\n        resolve(output.buffer);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}