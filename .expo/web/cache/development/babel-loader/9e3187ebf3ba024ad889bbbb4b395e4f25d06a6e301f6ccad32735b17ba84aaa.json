{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { CodedError } from 'expo-modules-core';\nimport { CryptoEncoding } from \"./Crypto.types\";\nvar getCrypto = function getCrypto() {\n  var _window$crypto;\n  return (_window$crypto = window.crypto) != null ? _window$crypto : window.msCrypto;\n};\nexport default {\n  get name() {\n    return 'ExpoCrypto';\n  },\n  digestStringAsync: function () {\n    var _digestStringAsync = _asyncToGenerator(function* (algorithm, data, options) {\n      if (!crypto.subtle) {\n        throw new CodedError('ERR_CRYPTO_UNAVAILABLE', 'Access to the WebCrypto API is restricted to secure origins (https).');\n      }\n      var encoder = new TextEncoder();\n      var buffer = encoder.encode(data);\n      var hashedData = yield crypto.subtle.digest(algorithm, buffer);\n      if (options.encoding === CryptoEncoding.HEX) {\n        return hexString(hashedData);\n      } else if (options.encoding === CryptoEncoding.BASE64) {\n        return btoa(String.fromCharCode.apply(String, _toConsumableArray(new Uint8Array(hashedData))));\n      }\n      throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n    });\n    function digestStringAsync(_x, _x2, _x3) {\n      return _digestStringAsync.apply(this, arguments);\n    }\n    return digestStringAsync;\n  }(),\n  getRandomBytes: function getRandomBytes(length) {\n    var array = new Uint8Array(length);\n    return getCrypto().getRandomValues(array);\n  },\n  getRandomBytesAsync: function () {\n    var _getRandomBytesAsync = _asyncToGenerator(function* (length) {\n      var array = new Uint8Array(length);\n      return getCrypto().getRandomValues(array);\n    });\n    function getRandomBytesAsync(_x4) {\n      return _getRandomBytesAsync.apply(this, arguments);\n    }\n    return getRandomBytesAsync;\n  }(),\n  getRandomValues: function getRandomValues(typedArray) {\n    return getCrypto().getRandomValues(typedArray);\n  },\n  randomUUID: function randomUUID() {\n    return getCrypto().randomUUID();\n  },\n  digestAsync: function digestAsync(algorithm, data) {\n    return getCrypto().subtle.digest(algorithm, data);\n  }\n};\nfunction hexString(buffer) {\n  var byteArray = new Uint8Array(buffer);\n  var hexCodes = _toConsumableArray(byteArray).map(function (value) {\n    var hexCode = value.toString(16);\n    var paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n  return hexCodes.join('');\n}","map":{"version":3,"names":["CodedError","CryptoEncoding","getCrypto","_window$crypto","window","crypto","msCrypto","name","digestStringAsync","_digestStringAsync","_asyncToGenerator","algorithm","data","options","subtle","encoder","TextEncoder","buffer","encode","hashedData","digest","encoding","HEX","hexString","BASE64","btoa","String","fromCharCode","apply","_toConsumableArray","Uint8Array","_x","_x2","_x3","arguments","getRandomBytes","length","array","getRandomValues","getRandomBytesAsync","_getRandomBytesAsync","_x4","typedArray","randomUUID","digestAsync","byteArray","hexCodes","map","value","hexCode","toString","paddedHexCode","padStart","join"],"sources":["/Users/wmaeda/Documents/me/React Native/react-native-boilerplate/node_modules/expo-crypto/src/ExpoCrypto.web.ts"],"sourcesContent":["import { CodedError, TypedArray } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions } from './Crypto.types';\n\nconst getCrypto = (): Crypto => window.crypto ?? (window as any).msCrypto;\n\nexport default {\n  get name(): string {\n    return 'ExpoCrypto';\n  },\n  async digestStringAsync(\n    algorithm: CryptoDigestAlgorithm,\n    data: string,\n    options: CryptoDigestOptions\n  ): Promise<string> {\n    if (!crypto.subtle) {\n      throw new CodedError(\n        'ERR_CRYPTO_UNAVAILABLE',\n        'Access to the WebCrypto API is restricted to secure origins (https).'\n      );\n    }\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n  getRandomBytes(length: number): Uint8Array {\n    const array = new Uint8Array(length);\n    return getCrypto().getRandomValues(array);\n  },\n  async getRandomBytesAsync(length: number): Promise<Uint8Array> {\n    const array = new Uint8Array(length);\n    return getCrypto().getRandomValues(array);\n  },\n  getRandomValues(typedArray: TypedArray) {\n    return getCrypto().getRandomValues(typedArray);\n  },\n  randomUUID() {\n    return getCrypto().randomUUID();\n  },\n  digestAsync(algorithm: AlgorithmIdentifier, data: ArrayBuffer): Promise<ArrayBuffer> {\n    return getCrypto().subtle.digest(algorithm, data);\n  },\n};\n\nfunction hexString(buffer: ArrayBuffer): string {\n  const byteArray = new Uint8Array(buffer);\n\n  const hexCodes = [...byteArray].map((value) => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}